float TIME_FROM_INIT : Time0_X;
float2 SCREEN_SIZE : ViewportDimensions;  

struct VS_OUTPUT 
{
   float4 Position : POSITION0;
   float2 TexCoord : TEXCOORD0;
};

float4 mod289(float4 x)
{
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}
 
float4 permute(float4 x)
{
    return mod289(((x*34.0)+1.0)*x);
}
 
float4 taylorInvSqrt(float4 r)
{
    return 1.79284291400159 - 0.85373472095314 * r;
}
 
float2 fade(float2 t) 
{
    return t*t*t*(t*(t*6.0-15.0)+10.0);
}
 
// Classic Perlin noise
float cnoise(float2 P)
{
    float4 Pi = floor(P.xyxy) + float4(0.0, 0.0, 1.0, 1.0);
    float4 Pf = frac(P.xyxy) - float4(0.0, 0.0, 1.0, 1.0);
    Pi = mod289(Pi); // To avoid truncation effects in permutation
    float4 ix = Pi.xzxz;
    float4 iy = Pi.yyww;
    float4 fx = Pf.xzxz;
    float4 fy = Pf.yyww;
     
    float4 i = permute(permute(ix) + iy);
     
    float4 gx = frac(i * (1.0 / 41.0)) * 2.0 - 1.0 ;
    float4 gy = abs(gx) - 0.5 ;
    float4 tx = floor(gx + 0.5);
    gx = gx - tx;
     
    float2 g00 = float2(gx.x,gy.x);
    float2 g10 = float2(gx.y,gy.y);
    float2 g01 = float2(gx.z,gy.z);
    float2 g11 = float2(gx.w,gy.w);
     
    float4 norm = taylorInvSqrt(float4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));
    g00 *= norm.x;  
    g01 *= norm.y;  
    g10 *= norm.z;  
    g11 *= norm.w;  
     
    float n00 = dot(g00, float2(fx.x, fy.x));
    float n10 = dot(g10, float2(fx.y, fy.y));
    float n01 = dot(g01, float2(fx.z, fy.z));
    float n11 = dot(g11, float2(fx.w, fy.w));
     
    float2 fade_xy = fade(Pf.xy);
    float2 n_x = lerp(float2(n00, n01), float2(n10, n11), fade_xy.x);
    float n_xy = lerp(n_x.x, n_x.y, fade_xy.y);
    return 2.3 * n_xy;
}
 
// Classic Perlin noise, periodic variant
float pnoise(float2 P, float2 rep)
{
    float4 Pi = floor(P.xyxy) + float4(0.0, 0.0, 1.0, 1.0);
    float4 Pf = frac(P.xyxy) - float4(0.0, 0.0, 1.0, 1.0);
    Pi = fmod(Pi, rep.xyxy); // To create noise with explicit period
    Pi = mod289(Pi);         // To avoid truncation effects in permutation
    float4 ix = Pi.xzxz;
    float4 iy = Pi.yyww;
    float4 fx = Pf.xzxz;
    float4 fy = Pf.yyww;
     
    float4 i = permute(permute(ix) + iy);
     
    float4 gx = frac(i * (1.0 / 41.0)) * 2.0 - 1.0 ;
    float4 gy = abs(gx) - 0.5 ;
    float4 tx = floor(gx + 0.5);
    gx = gx - tx;
     
    float2 g00 = float2(gx.x,gy.x);
    float2 g10 = float2(gx.y,gy.y);
    float2 g01 = float2(gx.z,gy.z);
    float2 g11 = float2(gx.w,gy.w);
     
    float4 norm = taylorInvSqrt(float4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));
    g00 *= norm.x;  
    g01 *= norm.y;  
    g10 *= norm.z;  
    g11 *= norm.w;  
     
    float n00 = dot(g00, float2(fx.x, fy.x));
    float n10 = dot(g10, float2(fx.y, fy.y));
    float n01 = dot(g01, float2(fx.z, fy.z));
    float n11 = dot(g11, float2(fx.w, fy.w));
     
    float2 fade_xy = fade(Pf.xy);
    float2 n_x = lerp(float2(n00, n01), float2(n10, n11), fade_xy.x);
    float n_xy = lerp(n_x.x, n_x.y, fade_xy.y);
    return 2.3 * n_xy;
}
 
float fbm(float2 P, int octaves, float lacunarity, float gain)
{
    float sum = 0.0;
    float amp = 1.0;
    float2 pp = P;
     
    int i;
     
    for(i = 0; i < octaves; i+=1)
    {
        amp *= gain; 
        sum += amp * cnoise(pp);
        pp *= lacunarity;
    }
    return sum;
 
}
 
float pattern(in float2 p)
{
    float l = 2.5;
    float g = 0.4;
    int oc = 10;
     
    float2 q = float2( fbm( p + float2(0.0,0.0),oc,l,g),fbm( p + float2(5.2,1.3),oc,l,g));
    float2 r = float2( fbm( p + 4.0*q + float2(1.7,9.2),oc,l,g ), fbm( p + 4.0*q + float2(8.3,2.8) ,oc,l,g));
    return fbm( p + 4.0*r ,oc,l,g);    
}
 
float pattern2(float2 p, float2 q, float2 r, float time)
{
    float l = 2.8;
    float g = 0.2;
    int oc = 20; 
     
    q.x = fbm(p + float2(time, time), oc, l, g);
    q.y = fbm(p + float2(5.2 * time, 1.3 * time), oc, l, g);
     
    r.x = fbm(p + 4.0 * q + float2(1.7, 9.2), oc, l, g);
    r.y = fbm(p + 4.0 * q + float2(8.3, 2.8), oc, l, g);
     
    return fbm(p + 4.0 * r, oc, l, g);
}

float4 ps_main(VS_OUTPUT Input) : COLOR0
{
    float2 q = Input.TexCoord * SCREEN_SIZE;
    float2 p = -1.0 + 2.0 * q, qq = float2(0.0, 0.0), r = float2(0.0, 0.0);
    
    float l_RandColor = clamp(pattern2(p, qq, r, TIME_FROM_INIT * 0.00001), 0, 1);
    float4 l_Color = float4(l_RandColor, 1, 0, 1.0) * 8.5;
    
    return l_Color;
}